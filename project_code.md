```python
# ./.gitattributes
# Auto detect text files and perform LF normalization
* text=auto

```
```python
# ./.gitignore
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb

# typescript
lib-cov
*.seed
*.log
*.csv
*.dat
*.out
*.pid
*.gz
*.swp

pids
logs
results
tmp

# Build
public/css/main.css

# Coverage reports
coverage

# API keys and secrets
.env

# Dependency directory
node_modules
bower_components

# Editors
.idea
*.iml

# OS metadata
.DS_Store
Thumbs.db

# Ignore built ts files
dist/**/*

# ignore yarn.lock
yarn.lock
```
```python
# ./README.md
# tutorial level
 Обучающий уровень для "Сайта с играми на программирование"

Отслеживать изменения и при сохранении запускать тесты.
```console
cargo install cargo-watch
```
=> перейти в папку приложения
```console
cargo watch -x run
```

Сделать WASM
```console
cargo build --target wasm32-unknown-unknown; cp target/wasm32-unknown-unknown/debug/*.wasm
```
```
```python
# ./sandbox.py
import os
from pprint import pprint

md_filename = "project_code.md"


def get_project_files(directory="./"):
    file_list = []
    ignore_dirs = [
        'venv',
        'node_modules',
        'target',
        '.git',
        '.idea',
    ]

    for root, dirs, files in os.walk(directory):
        for ignd in ignore_dirs:
            if ignd in dirs:
                dirs.remove(ignd)
        for file in files:
            # if file.endswith(".py"):  # Фильтруем только .py файлы
            if file.startswith("LICENSE") \
                    or file == md_filename \
                    or file.endswith(".lock"):
                continue
            try:
                file_list.append(os.path.join(root, file))
            except:
                continue
    return file_list


# Получите список файлов в проекте
project_directory = "./"
file_list = get_project_files(project_directory)

# Создайте новый Markdown-файл

# Откройте файл для записи
with open(md_filename, "w", encoding="utf-8") as md_file:
    # Добавьте содержимое каждого файла Python в Markdown-файл
    for file in file_list:
        with open(file, "r", encoding="utf-8") as python_file:
            try:
                code = python_file.read()
                md_file.write(f"```python\n# {file}\n{code}\n```\n")
            except:
                print("SKIP", file)

print(f"Собраны файлы в {md_filename}")

if __name__ == "__main__":
    pprint(get_project_files())

```
```python
# ./css\main.css
article, aside, details, figcaption, figure, footer,header,
hgroup, menu, nav, section {
    display: block;
}

body {
    background-color: #F9F9F9;
    font-size: 30px;

}

img {
    max-width: 700px;
}

.item {
    background-color: #FFFFFF;
    color: #242424;
    max-width: 750px;
    margin: 30px auto;
    padding: 40px;
}

.btn-link,
.item_header {
    font-size: 42px;
}

.github_link {
    float: right;
}

.intro {
    background-color: #242424;
    color: white;
    padding: 20px;
}

.description {

}

.btn-link {
    color: #242424;
    text-decoration: none;
}

```
```python
# ./lvl_0\Cargo.toml
[package]
name = "lvl_0"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
macroquad = "0.3.26"
quad-url = "0.1.1"

```
```python
# ./lvl_0\index.html
<!doctype html>
<html class="" lang="ru">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- CSS only -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <!-- install pyodide version 0.20.0 -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.20.0/full/pyodide.js"></script>
    <!-- import codemirror stylings -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.min.css" />
    <!-- install codemirror.js version /5.63.3 from cdn -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.63.3/codemirror.min.js"
        integrity="sha512-XMlgZzPyVXf1I/wbGnofk1Hfdx+zAWyZjh6c21yGo/k1zNC4Ve6xcQnTDTCHrjFGsOrVicJsBURLYktVEu/8vQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!-- install codemirror python language support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.63.3/mode/python/python.min.js"
        integrity="sha512-/mavDpedrvPG/0Grj2Ughxte/fsm42ZmZWWpHz1jCbzd5ECv8CB7PomGtw0NAnhHmE/lkDFkRMupjoohbKNA1Q=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!--  jquery-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js"
        integrity="sha512-aVKKRRi/Q/YV+4mjoKBsE4x3H+BkegoM/em46NNlCqNTmUYADjBbeNefNxYV7giUp0VxICtqdrbqU7iVaeZNXA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!-- import codemirror dracula theme styles from cdn -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.63.3/theme/dracula.css" />
    <!--suppress CssUnresolvedCustomProperty -->
    <style>
        body {

            --cell-width: calc(50vw - 10px);
            --bot-cell-min-heigt: 200px;
            --ide-color: #202531;
            --ide-border-color: #262C3B;

            color: rgb(173, 173, 173);
            background: black;


        }

        .CodeMirror {
            height: 100%;
            width: 100%;

        }

        td {
            vertical-align: top;
        }

        td>div {
            margin-top: 4px;
            min-width: var(--cell-width);
            border: 2px solid var(--ide-border-color);
        }

        .CodeMirror-scroll,
        td>div {
            background: var(--ide-color);
        }

        .ide-code {
            height: 100%;
            min-height: var(--cell-width);
        }

        #code {
            height: 100%;
        }

        .game_window {
            width: var(--cell-width);
            height: var(--cell-width);
        }

        #task_wnd {
            display: none;
            min-width: var(--cell-width);
            min-height: var(--cell-width);
        }

        #output {
            background: black;
            width: 100%;
            color: gainsboro;
            border: none;
        }

        .tests,
        #output {
            min-height: var(--bot-cell-min-heigt);
        }

        .btn-ide {
            background: #464D56;
            color: cadetblue;
        }
    </style>
    <title></title>
</head>

<body>

    <table>

        <tr>
            <td>
                <div>
                    <button type="button" class="btn btn-dark btn-ide" onclick="showTaskDescription()">Описание</button>
                    <button type="button" class="btn btn-dark btn-ide" onclick="showGameWindow()">Игра</button>
                </div>
            </td>
            <td>
                <div>
                    <!-- clean the output section -->
                    <button type="button" class="btn btn-dark btn-ide" onclick="clearHistory()">Python <span
                            id="python_version">3</span></button>
                </div>
            </td>
        </tr>

        <tr>

            <td>
                <div id="game_wnd">
                    <canvas class="game_window" id="glcanvas" tabindex='1' oncontextmenu="return false;"></canvas>
                </div>
                <div id="task_wnd">
                    <h4>Описание задачи</h4>
                    <p>Попади в мишень.</p>
                    <p>Известны положения юникта и мишени в системе координат.</p>
                    <p>Можно использовать страндартные библиотеки Python и библиотеку numpy.</p>
                    <p>Можно управлять вручную. WASD, ← → ↑ ↓, мышка.</p>
                    <p></p>
                    <p></p>

                    <details>
                        <summary>Подсказка 1</summary>
                        <p>Арктангенс.</p>
                    </details>

                    <details>
                        <summary>Подсказка 2</summary>
                        <div style="background: #242424">
                            <pre>
                        <code>
    import numpy as np
    ...
    ...

    dx = target_pos[0] - unit_pos[0]
    dy = target_pos[1] - unit_pos[1]

    return 180 - np.rad2deg(np.arctan2(dx, dy))
                        </code>
                    </pre>
                        </div>
                    </details>

                </div>
                <div>
                    <textarea readonly class="" id="output" name="output"></textarea>
                </div>
            </td>

            <td>

                <div class="ide-code">
                    <textarea id="code" name="code" class="h-full"></textarea>
                </div>
                <div class="tests">
                    <!-- run button to pass the code to pyodide.runPython() -->
                    <button type="button" class="btn btn-dark btn-ide" onclick="showGameWindow(); evaluatePython();">
                        ▶︎ Тест
                    </button>
                    <!-- clean the output section -->
                    <!--            <button class="btn btn-dark btn-ide" onclick="clearHistory()" type="button">CLS</button>-->
                </div>

            </td>

        </tr>
    </table>

    <script>
        // показать task_wnd
        function showGameWindow() {
            document.getElementById("game_wnd").style.display = "block";
            document.getElementById("task_wnd").style.display = "none";
        }

        // показать game_wnd
        function showTaskDescription() {
            document.getElementById("game_wnd").style.display = "none";
            document.getElementById("task_wnd").style.display = "block";
        }
    </script>

    <script src="https://not-fl3.github.io/miniquad-samples/mq_js_bundle.js"></script>
    <script src="https://evgene-kopylov.github.io/js-imports.github.io/sapp_jsutils.js"></script>
    <script src="https://evgene-kopylov.github.io/js-imports.github.io/quad-url.js"></script>
    <script>load("lvl_0.wasm");</script>
    <script src="python_in_browser/static/js/main.js"></script>
</body>

</html>
```
```python
# ./lvl_0\python_in_browser\static\js\main.js
// find the output element
const output = document.getElementById("output");
// initializing the codemirror and pass configuration to support python and dracula theme
const editor = CodeMirror.fromTextArea(document.getElementById("code"), {
              mode: {
                  name: "python",
                  version: 3,
                  singleLineStringErrors: false,
              },
              theme: "dracula",
              lineNumbers: true,
              indentUnit: 4,
              matchBrackets: true,
            });

const function_name = "function";

// set the initial value of the editor
editor.setValue(`
def ${function_name}(
    enemy_units: [(int, int)],
    self_pos: (int, int)
) -> (int, int):
    """
    Выбери цель для стрельбы
    
    @enemy_units: список координат коричневых целей 
    @return: точка прицеливания
    """
    
    ### Вставьте вашь код сюда
    
    distance = 10000
    target = (0, 0)
    for unit in enemy_units:
        dx = self_pos[0] - unit[0]
        dy = self_pos[1] - unit[1]
        dis = (dx * dx + dy * dy) ** 0.5
        if dis < distance:
            distance = dis
            target = (unit[0], unit[1])

    return target
`);
output.value = "Initializing...\n";

// Add pyodide returned value to the output
function addToOutput(stdout) {
  output.value += stdout;
  output.scrollTop = output.scrollHeight;
}

// Clean the output section
function clearHistory() {
  output.value = "";
}

// init Pyodide and show sys.version when it's loaded successfully
async function main() {
  let pyodide = await loadPyodide();
  await pyodide.loadPackage('numpy');

    output.value = pyodide.runPython(`
import sys
sys.version
  `);
  output.value += `
Python ${output.value.split(" ")[0]}

`;

  // Версия Python в заголовке IDE
  let element = window.document.getElementById("python_version");
  element.innerText = output.value.split(" ")[0];

  return pyodide;
}
// run the main funciton
let pyodideReadyPromise = main();

function setParameter(name, value) {
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    urlParams.set(name, value);
    const newurl = window.location.protocol
        + "//" + window.location.host
        + window.location.pathname
        + '?' + urlParams;
    window.history.pushState({path:newurl},'',newurl);
}

function getParameterValue(name) {
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    return decodeURI(urlParams.get(name));
}


function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// pass the editor value to the pyodide.runPython function and show the result in the output section
async function evaluatePython(test = 'all') {
    let target_pos = getParameterValue('target_pos');
    let enemy_units = getParameterValue('enemy_units');
    let unit_pos = getParameterValue('unit_pos');

    let pyodide = await pyodideReadyPromise;
    try {
        // test_positions = [
        //     '(100, 100)',
        //     '(136, 275)',
        //     '(430, 361)',
        //     '(489, 204)'
        // ]
        // test_positions.push(unit_pos);

        // for (target of enemy_units) {
            console.log(enemy_units);
            pyodide.runPython(`    
import io
sys.stdout = io.StringIO()

enemy_units = ${enemy_units}
self_pos = ${unit_pos}
        `);
        pyodide.runPython(`
${editor.getValue()}    
target = ${function_name}(enemy_units, self_pos)
print(target)
        `);


            let stdout = pyodide.runPython("sys.stdout.getvalue()");

            let result = stdout.toString().trim().split("\n")
            console.log(result);
            // addToOutput(`>>> ${function_name}(${target_pos}, ${unit_pos})\n` + stdout);

            let target = result[0].replace('(', '').replace(')', '').split(', ');
            console.log(target)
            setParameter("target_point_x", target[0]);
            setParameter("target_point_y", target[1]);

            // setParameter("unit_position_y", unit_pos.replace('(', '').replace(')', '').split(', ')[1]);
            // setParameter("rotation", rotation.toString().trim());

            setParameter("command", "Shoot");
            await sleep(1000);
        // };
  } catch (err) {
    addToOutput(err);
  }
}
```
```python
# ./lvl_0\src\assets.rs
//! ассеты с предворительной загрузкой

use macroquad::audio::{load_sound, Sound};
use macroquad::prelude::{info, FileError};
use macroquad::texture::{load_texture, Texture2D};

/// Набор ассетов. Текстуры и звуки.
pub(crate) struct Assets {
    pub(crate) main_unit_texture: Texture2D,
    pub(crate) main_unit_shoot_sound: Sound,
    pub(crate) target_impact_sound: Sound,
    pub(crate) target_unit_texture: Texture2D,
    pub(crate) target_unit_shadow_texture: Texture2D,
    pub(crate) projectile_texture: Texture2D,
    pub(crate) enemy_unit_gray: Texture2D,
}

impl Assets {
    /// Читать файлы ассетов
    pub async fn new() -> Result<Self, FileError> {
        info!("WASM LOG: Начало загрузки текстур");
        let main_unit_texture: Texture2D = load_texture("../assets/pointer/pointer_3.png").await?;
        let main_unit_shoot_sound: Sound = load_sound("../assets/sound/4 XSA_Weapon.wav").await?;
        let target_impact_sound: Sound =
            load_sound("../assets/sound/hit-with-something.wav").await?;
        let target_unit_texture = load_texture("../assets/pointer/target_unit_3_2.png").await?;
        let target_unit_shadow_texture =
            load_texture("../assets/pointer/target_unit_3_shadow.png").await?;
        let enemy_unit_gray = load_texture("../assets/pointer/enemy_unit_gray.png").await?;
        let projectile_texture = load_texture("../assets/pointer/projectile_glow_7.png").await?;
        info!("WASM LOG: Текстуры загружены");

        Ok(Self {
            main_unit_texture,
            main_unit_shoot_sound,
            target_impact_sound,
            target_unit_texture,
            target_unit_shadow_texture,
            enemy_unit_gray,
            projectile_texture,
        })
    }
}

```
```python
# ./lvl_0\src\command.rs
use macroquad::math::Vec2;

pub struct Command {
    pub shoot: bool,
    pub wasd: Vec2, // смещение
    pub rotation: f32,
}

impl Command {
    pub fn new() -> Self {
        Self {
            shoot: false,
            wasd: Vec2::new(0., 0.),
            rotation: 0.,
        }
    }
}

```
```python
# ./lvl_0\src\main.rs
// #![allow(unused)] // FIXME

use macroquad::prelude::*;

mod settings;
use settings::*;

mod assets;
mod command;
mod scene;
mod units;
mod utils;

use crate::scene::Scene;

#[macroquad::main(window_conf)]
async fn main() {
    let mut scene = Scene::new().await;

    loop {
        scene.update();
        clear_background(GROUND_COLOR);
        scene.draw();
        next_frame().await
    }
}

```
```python
# ./lvl_0\src\scene.rs
use crate::assets::Assets;
use crate::command::Command;
use crate::settings::ENEMY_UNIT_IMPACT_SOUND_VOLUME;
use crate::units::enemy_unit::EnemyUnit;
use crate::units::main_unit::MainUnit;
use crate::units::projectile::Projectile;
use crate::units::target_unit::TargetUnit;
use crate::utils::get_parameter_value;
use macroquad::audio::{self, PlaySoundParams};
use macroquad::input::{is_key_down, KeyCode};
use macroquad::prelude::{info, mouse_position, screen_height, screen_width, Vec2};
use macroquad::time::get_frame_time;
use quad_url::set_program_parameter;

pub struct Scene {
    main_unit: MainUnit,
    target_unit: TargetUnit,
    enemy_units: Vec<EnemyUnit>,
    projectiles: Vec<Projectile>,
    dt: f32,
    assets: Assets,
    command: Command,
    tick: f32,
    target_point: Vec2,
}

impl Scene {
    /// создание экземпляра Сцены
    pub async fn new() -> Self {
        let spawn_position = Vec2::new(screen_width() * 0.5, screen_height() * 0.8);
        let target_unit_position = Vec2::new(screen_width() * 0.5, 160.);

        let mouse_position: Vec2 = mouse_position().into();
        let dt = get_frame_time();
        let assets = Assets::new().await.unwrap();

        let mut scene = Self {
            main_unit: MainUnit::new(assets.main_unit_texture, spawn_position),
            target_unit: TargetUnit::new(
                assets.target_unit_texture,
                assets.target_unit_shadow_texture,
                assets.target_impact_sound,
                target_unit_position,
            ),
            enemy_units: Vec::new(),
            projectiles: vec![],
            dt,
            assets,
            command: Command::new(),
            tick: 1000., // большое число, чтобы сразу срабатывало
            target_point: mouse_position,
        };
        scene.start();
        scene
    }

    /// запустить игру.
    fn start(&mut self) {
        // спавн `enemy_units`
        // слево
        self.spawn_single_enemy_unit(-100., 0.);
        self.spawn_single_enemy_unit(-200., 0.);
        // справа
        self.spawn_single_enemy_unit(100., 0.);
        self.spawn_single_enemy_unit(200., 0.);
        // впереди
        // self.spawn_single_enemy_unit(0., 100.);
    }

    /// перезапустить игру
    /// здоровье юнитов и позиции будут восстановленны
    fn restart(&mut self) {
        // очистить поле
        self.enemy_units = vec![];

        // восстановить `target_unit`
        self.target_unit.hit_points = 100.;
        self.target_unit.alive = true;

        self.start();
    }

    /// создать enemy_unit по координатам относительно `target_unit`
    fn spawn_single_enemy_unit(&mut self, dx: f32, dy: f32) {
        let x = self.target_unit.position.x + dx;
        let y = self.target_unit.position.y + dy;
        let unit = EnemyUnit::new(
            self.assets.enemy_unit_gray,
            self.assets.target_unit_shadow_texture,
            self.assets.target_impact_sound,
            Vec2 { x, y },
        );
        self.enemy_units.push(unit);
    }

    /// Поймать активность пользователя.
    fn update_command_from_user_input(&mut self) {
        let mut x_move = 0f32;
        if is_key_down(KeyCode::Left) || is_key_down(KeyCode::A) {
            x_move -= 1f32;
        }
        if is_key_down(KeyCode::Right) || is_key_down(KeyCode::D) {
            x_move += 1f32;
        }

        let mut y_move = 0f32;
        if is_key_down(KeyCode::Up) || is_key_down(KeyCode::W) {
            y_move -= 1f32;
        }
        if is_key_down(KeyCode::Down) || is_key_down(KeyCode::S) {
            y_move += 1f32;
        }

        if self.main_unit.position.x < 1f32 {
            x_move = 1f32;
        }
        if self.main_unit.position.x > screen_width() {
            x_move = -1f32;
        }

        if self.main_unit.position.y < 1f32 {
            y_move = 1f32;
        }
        if self.main_unit.position.y > screen_height() {
            y_move = -1f32;
        }
        self.command.wasd = Vec2::new(x_move, y_move);
    }

    /// Обновить `Command` из URL аргументов
    fn update_command_from_url_query(&mut self) {
        if get_parameter_value("command") == *"Shoot" {
            // self.restart();
            self.command.shoot = true;
            let x = get_parameter_value("target_point_x").parse().unwrap_or(0.);
            let y = get_parameter_value("target_point_y").parse().unwrap_or(0.);
            self.target_point = Vec2::new(x, y);
            info!("{:?}", self.target_point);
            set_program_parameter("command", "");
            self.main_unit.shoot_timer = 1.; // чтобы получить выстрел с минимальной задержкой
            self.main_unit.auto_aim = true;
        }

        match get_parameter_value("rotation").parse::<f32>() {
            Ok(a) => {
                self.command.rotation = a.to_radians();
            }
            Err(_e) => {
                // info!("{}", _e);
            }
        }
    }

    /// передать параметры в URL аргементы
    fn set_parameters_to_url_query(&mut self) {
        let line = format!(
            "({}, {})",
            self.target_unit.position.x as i32, self.target_unit.position.y as i32
        );
        set_program_parameter("target_pos", line.as_str());
        let line = format!(
            "({}, {})",
            self.main_unit.position.x as i32, self.main_unit.position.y as i32
        );
        set_program_parameter("unit_pos", line.as_str());

        let mut line = "[".to_string();
        for i in 0..self.enemy_units.len() {
            let value = format!(
                "({}, {}), ",
                self.enemy_units[i].position.x as i32, self.enemy_units[i].position.y as i32
            );
            line += &value;
        }
        line += "]";
        set_program_parameter("enemy_units", &line);
    }

    /// Обновить сцену
    pub fn update(&mut self) {
        self.tick += self.dt;
        self.update_command_from_user_input();

        if self.tick >= 1. {
            self.tick = 0.0;
            self.set_parameters_to_url_query();
            self.update_command_from_url_query();
        }
        self.dt = get_frame_time();
        self.target_unit.shift = Vec2::new(0., 0.);

        // стрельба и спавн выстрела
        self.main_unit_shoot();

        // удалить дохлые юниты
        self.remove_dead_enemy_units();

        // обновить всех коричневыз
        self.update_enemy_units();

        // Удаление снарядов на отлете
        self.remove_projectile_out_of_range();

        // поражение главной мишени
        self.target_unit_hit();

        // поражение enemy_units
        self.enemy_units_hit();
    }

    /// стрельба и спавн выстрела
    fn main_unit_shoot(&mut self) {
        let target_point = if self.target_point.x != 0. || self.target_point.y != 0. {
            self.target_point
        } else {
            mouse_position().into()
        };

        self.main_unit
            .update(self.dt, target_point, &mut self.command);
        if self.command.shoot {
            let position = Vec2::new(
                // точка появления выстрела
                self.main_unit.position.x
                    + 65. * (self.main_unit.rotation - f32::to_radians(90.)).cos(),
                self.main_unit.position.y
                    + 65. * (self.main_unit.rotation - f32::to_radians(90.)).sin(),
            );

            let projectile = Projectile::new(
                self.assets.projectile_texture,
                self.assets.main_unit_shoot_sound,
                self.main_unit.rotation,
                position,
                self.main_unit.speed * 3.,
            );
            self.projectiles.push(projectile);
        }
    }

    /// Обновить все `enemy_units`
    fn update_enemy_units(&mut self) {
        for i in 0..self.enemy_units.len() {
            let units = self.enemy_units.clone();
            self.enemy_units[i].update(self.dt, self.main_unit.position, units, i);
        }
    }

    /// удалить дохлые юниты
    fn remove_dead_enemy_units(&mut self) {
        self.enemy_units.retain(|u| u.hit_points > 0.);
    }

    /// Удаление снарядов на отлете
    fn remove_projectile_out_of_range(&mut self) {
        self.projectiles.retain(|p| {
            ((p.start_position.x - p.position.x).powf(2f32)
                + (p.start_position.y - p.position.y).powf(2f32)
                < self.main_unit.shoot_range.powf(2f32))
                && p.alive
        });
    }

    /// поражение главной мишени
    fn target_unit_hit(&mut self) {
        for i in 0..self.projectiles.len() {
            let p = &mut self.projectiles[i];

            if (p.position.x - self.target_unit.position.x).powf(2f32)
                + (p.position.y - self.target_unit.position.y).powf(2f32)
                < self.target_unit.radius.powf(2f32)
            {
                p.alive = false;
                self.target_unit.update(true, -20., p.rotation);
                info!("target_unit.hit_points: {:?}", self.target_unit.hit_points);
                if self.target_unit.hit_points <= -100. {
                    self.restart();
                }
            } else {
                p.update(self.dt);
            }
        }
    }

    /// поражение enemy_units
    fn enemy_units_hit(&mut self) {
        for i in 0..self.projectiles.len() {
            let p = &mut self.projectiles[i];
            for j in 0..self.enemy_units.len() {
                let u = &mut self.enemy_units[j];
                let dx = p.position.x - u.position.x;
                let dy = p.position.y - u.position.y;
                let dist = (dx.powf(2.) + dy.powf(2.)).sqrt();
                if dist < u.radius {
                    u.hit_points -= 20.;
                    audio::play_sound(
                        u.impact_sound,
                        PlaySoundParams {
                            volume: ENEMY_UNIT_IMPACT_SOUND_VOLUME,
                            ..Default::default()
                        },
                    );

                    let da = u.rotation - p.rotation;
                    p.alive = false;
                    u.rotation += (da.abs() / da) * f32::to_radians(20.);
                }
            }
        }
    }

    /// отрисовка
    pub fn draw(&self) {
        self.target_unit.draw_shadow();
        self.main_unit.draw();
        for i in 0..self.enemy_units.len() {
            self.enemy_units[i].draw_shadow();
            self.enemy_units[i].draw();
        }
        for i in 0..self.projectiles.len() {
            self.projectiles[i].draw();
        }
        self.target_unit.draw();
    }
}

```
```python
# ./lvl_0\src\settings.rs
use macroquad::prelude::{Color, Conf};

pub const GROUND_COLOR: Color = Color::new(0.77, 0.8, 0.8, 1.00);
pub const UNIT_COLOR: Color = Color::new(0.94, 0.94, 0.94, 1.);
pub const PROJECTILE_COLOR: Color = Color::new(1.00, 0.96, 0.84, 1.00);

pub const MAIN_UNIT_SPEED: f32 = 300.;
pub const MAIN_UNIT_SHOOT_DELAY: f32 = 0.1;
pub const MAIN_UNIT_SHOOT_RANGE: f32 = 3000.;
pub const MAIN_UNIT_SHOOT_SOUND_VOLUME: f32 = 0.16;
pub const TARGET_UNIT_IMPACT_SOUND_VOLUME: f32 = 0.345;

pub const ENEMY_UNIT_ROTATION_SPEED: f32 = 4.0;
pub const ENEMY_UNIT_SPEED: f32 = 130.0;
pub const ENEMY_UNIT_IMPACT_SOUND_VOLUME: f32 = 0.08;

pub fn window_conf() -> Conf {
    Conf {
        window_title: String::from("lvl_0"),
        window_width: 800,
        window_height: 800,
        window_resizable: false,
        ..Default::default()
    }
}

```
```python
# ./lvl_0\src\utils.rs
use quad_url::get_program_parameters;

pub fn get_parameter_value(arg: &str) -> String {
    let parameters = get_program_parameters();
    for parameter in parameters.iter() {
        if parameter.starts_with("--") {
            let para = parameter.strip_prefix("--").unwrap();
            let para = para.to_string();
            let para2: Vec<&str> = para.split('=').collect();
            if para2.len() == 2 && para2[0] == arg {
                return para2[1].to_string();
            }
        }
    }
    String::new()
}

```
```python
# ./lvl_0\src\units\enemy_unit.rs
use crate::settings::*;
use crate::Vec2;
use macroquad::audio::Sound;
use macroquad::color::{BLACK, GREEN};
use macroquad::prelude::{draw_texture_ex, Color, DrawTextureParams, Texture2D, BROWN}; // FIXME

#[derive(Clone)]
pub struct EnemyUnit {
    pub texture: Texture2D,
    pub shadow_texture: Texture2D,
    color: Color,
    pub position: Vec2,
    pub rotation: f32,
    pub radius: f32,
    pub shift: Vec2,
    pub impact_sound: Sound,
    pub(crate) hit_points: f32,
    pub(crate) alive: bool,
}

impl EnemyUnit {
    pub fn new(
        texture: Texture2D,
        shadow_texture: Texture2D,
        impact_sound: Sound,
        spawn_position: Vec2,
    ) -> Self {
        let color = BLACK;

        Self {
            texture,
            shadow_texture,
            color,
            position: spawn_position,
            rotation: f32::to_radians(-90.0),
            radius: texture.width() * 0.5,
            shift: Vec2::new(0., 0.),
            impact_sound,
            hit_points: 100.,
            alive: true,
        }
    }

    pub fn draw(&self) {
        let color = if self.alive { BROWN } else { GREEN };

        draw_texture_ex(
            self.texture,
            self.position.x - self.texture.width() * 0.5 + self.shift.x,
            self.position.y - self.texture.height() * 0.5 - self.shift.y,
            color,
            DrawTextureParams {
                rotation: self.rotation - f32::to_radians(90.),
                ..Default::default()
            },
        );
    }

    pub fn draw_shadow(&self) {
        // тень
        let height = 1.6;
        let mut color = self.color;
        color.a = 0.2;
        draw_texture_ex(
            self.texture,
            self.position.x - self.texture.width() * 0.5 + 3. * height,
            self.position.y - self.texture.height() * 0.5 + 4. * height,
            color,
            DrawTextureParams {
                rotation: self.rotation - f32::to_radians(90.),
                ..Default::default()
            },
        );
    }

    pub fn update(&mut self, dt: f32, target: Vec2, units: Vec<EnemyUnit>, exclude: usize) {
        self.rotation %= f32::to_radians(360.);
        let mut dx = self.position.x - target.x;
        if dx == 0f32 {
            dx += 1f32;
        };

        let mut dy = self.position.y - target.y;
        if dy == 0f32 {
            dy += 1f32;
        };

        // абсолютный угол к целиwww
        let a: f32 = if dx >= 0. {
            (dy / dx).atan()
        } else {
            (dy / dx).atan() - f32::to_radians(180.)
        };

        // относительный угол
        let mut da = self.rotation - a;

        // убрать намотку угла
        if da <= f32::to_radians(-180.) {
            da += f32::to_radians(360.)
        }
        if da > f32::to_radians(180.) {
            da -= f32::to_radians(360.)
        }

        // сохранение направления движения
        if da.abs() > f32::to_radians(9.) {
            if da > 0. {
                self.rotation -= dt * ENEMY_UNIT_ROTATION_SPEED
            } else {
                self.rotation += dt * ENEMY_UNIT_ROTATION_SPEED
            }
        }

        self.swarm_behaviour(dt, units, exclude);

        self.position.x += -1. * dt * ENEMY_UNIT_SPEED * self.rotation.cos();
        self.position.y += -1. * dt * ENEMY_UNIT_SPEED * self.rotation.sin();
    }

    /// Роевое поведение
    fn swarm_behaviour(&mut self, dt: f32, units: Vec<EnemyUnit>, exclude: usize) {
        // отворот от близкого юнита
        for (i, unit) in units.iter().enumerate() {
            if i == exclude {
                continue;
            }
            let x0 = self.position.x;
            let y0 = self.position.y;
            let x1 = unit.position.x;
            let y1 = unit.position.y;
            let dx = x0 - x1;
            let dy = y0 - y1;
            let distance = (dx.powf(2.) + dy.powf(2.)).sqrt();
            if distance < 70. {
                // соседний юнит близко

                // абсолютный угол
                let a: f32 = if dx >= 0. {
                    (dy / dx).atan()
                } else {
                    (dy / dx).atan() - f32::to_radians(180.)
                };

                // относительный угол
                let da = self.rotation - a;

                // отворачивать от близкого юнита
                if da < 0. && da > -20. {
                    self.rotation -= 0.7 * dt * ENEMY_UNIT_ROTATION_SPEED
                } else if da > 0. && da < 20. {
                    self.rotation += 0.7 * dt * ENEMY_UNIT_ROTATION_SPEED
                }
            }
        }
    }
}

```
```python
# ./lvl_0\src\units\main_unit.rs
//! юнит под контролем игрока

use crate::command::Command;
use crate::settings::*;
use macroquad::prelude::*;


pub struct MainUnit {
    pub texture: Texture2D,
    pub size: Vec2,
    pub scale: f32,
    pub radius: f32,
    pub rotation: f32,
    pub position: Vec2,
    pub speed: f32,
    pub shoot_timer: f32,
    shoot_delay: f32,
    pub shoot_range: f32,
    pub auto_aim: bool,
    bullet_load: u8,
}

impl MainUnit {
    pub fn new(texture: Texture2D, position: Vec2) -> Self {
        Self {
            texture,
            position,
            size: Vec2::new(texture.width(), texture.height()),
            scale: 1.,
            radius: f32::max(texture.width(), texture.height()),
            rotation: 0.,
            speed: MAIN_UNIT_SPEED,
            shoot_timer: 0.,
            shoot_delay: MAIN_UNIT_SHOOT_DELAY,
            shoot_range: MAIN_UNIT_SHOOT_RANGE,
            auto_aim: false,
            bullet_load: 0,
        }
    }

    // Возвращает сигнал о попадании в цель
    pub fn update(&mut self, dt: f32, target_point: Vec2, command: &mut Command) {
        self.shoot_timer += dt;

        self.position.x += command.wasd.x * dt * self.speed;
        self.position.y += command.wasd.y * dt * self.speed;

        if command.wasd.x != 0. || command.wasd.y != 0. || is_mouse_button_down(MouseButton::Left) {
            self.auto_aim = false;
        }

        // поворот в сторону курсора
        self.rotation %= f32::to_radians(360.);
        let mut dx = self.position.x - target_point.x;
        if dx == 0f32 {
            dx += 1f32;
        };

        let mut dy = self.position.y - target_point.y;
        if dy == 0f32 {
            dy += 1f32;
        };

        if self.auto_aim {
            self.rotation = command.rotation;
        } else if !self.auto_aim {
            if dx >= 0f32 {
                self.rotation = (dy / dx).atan() - f32::to_radians(90.);
            } else {
                self.rotation = (dy / dx).atan() - f32::to_radians(270.);
            }
        }

        // Управление огнем
        if self.shoot_timer >= self.shoot_delay {
            if is_mouse_button_down(MouseButton::Left) {
                // ЛКМ
                command.shoot = true;
                self.bullet_load = 0;
            } else if self.bullet_load > 0 {
                // очередь
                command.shoot = true;
                self.bullet_load -= 1;
            }
        } else {
            command.shoot = false;
        }

        if command.shoot {
            self.shoot_timer = 0.;
        }
    }

    pub fn draw(&self) {
        // тень
        draw_texture_ex(
            self.texture,
            self.position.x - self.size.x * 0.5 + 3.,
            self.position.y - self.size.y * 0.5 + 4.,
            DARKGRAY,
            DrawTextureParams {
                dest_size: Some(Vec2::new(self.size.x, self.size.y)),
                rotation: self.rotation,
                ..Default::default()
            },
        );
        // сам юнит
        draw_texture_ex(
            self.texture,
            self.position.x - self.size.x * 0.5,
            self.position.y - self.size.y * 0.5,
            UNIT_COLOR,
            DrawTextureParams {
                dest_size: Some(Vec2::new(self.size.x, self.size.y)),
                rotation: self.rotation,
                ..Default::default()
            },
        );
    }
}

```
```python
# ./lvl_0\src\units\mod.rs
//! свойства юнитов

pub(crate) mod enemy_unit;
pub(crate) mod main_unit;
pub(crate) mod projectile;
pub(crate) mod target_unit;

```
```python
# ./lvl_0\src\units\projectile.rs
use crate::settings::*;
use macroquad::audio;
use macroquad::audio::{PlaySoundParams, Sound};
use macroquad::prelude::*;

pub struct Projectile {
    pub texture: Texture2D,
    pub rotation: f32,
    pub start_position: Vec2,
    pub position: Vec2,
    pub size: Vec2,
    pub speed: f32,
    pub alive: bool,
}

impl Projectile {
    pub fn new(
        texture: Texture2D,
        shoot_sound: Sound,
        rotation: f32,
        position: Vec2,
        speed: f32,
    ) -> Self {
        audio::play_sound(
            shoot_sound,
            PlaySoundParams {
                volume: MAIN_UNIT_SHOOT_SOUND_VOLUME,
                ..Default::default()
            },
        );

        let size = Vec2::new(texture.width(), texture.height());
        Self {
            texture,
            rotation,
            start_position: position,
            position,
            size,
            speed,
            alive: true,
        }
    }

    pub fn update(&mut self, dt: f32) {
        self.position.x += dt * self.speed * (self.rotation - f32::to_radians(90.)).cos();
        self.position.y += dt * self.speed * (self.rotation - f32::to_radians(90.)).sin();
    }

    pub fn draw(&self) {
        draw_texture_ex(
            self.texture,
            self.position.x - self.size.x * 0.50,
            self.position.y - self.size.y * 0.50,
            PROJECTILE_COLOR,
            DrawTextureParams {
                dest_size: Some(Vec2::new(self.size.x, self.size.y)),
                rotation: self.rotation,
                ..Default::default()
            },
        );
    }
}

```
```python
# ./lvl_0\src\units\target_unit.rs
use crate::{Vec2, TARGET_UNIT_IMPACT_SOUND_VOLUME};
use macroquad::audio;
use macroquad::audio::{PlaySoundParams, Sound};
use macroquad::color::{BLACK, GREEN, WHITE};
use macroquad::prelude::{draw_texture_ex, Color, DrawTextureParams, Texture2D};

pub struct TargetUnit {
    pub texture: Texture2D,
    pub shadow_texture: Texture2D,
    color: Color,
    pub position: Vec2,
    pub radius: f32,
    pub shift: Vec2,
    impact_sound: Sound,
    pub(crate) hit_points: f32,
    pub alive: bool,
}

impl TargetUnit {
    pub fn new(
        texture: Texture2D,
        shadow_texture: Texture2D,
        impact_sound: Sound,
        spawn_position: Vec2,
    ) -> Self {
        let mut color = BLACK;
        color.a = 0.45;

        Self {
            texture,
            shadow_texture,
            color,
            position: spawn_position,
            radius: texture.width() * 0.5,
            shift: Vec2::new(0., 0.),
            impact_sound,
            hit_points: 100.,
            alive: true,
        }
    }

    pub fn update(&mut self, impact: bool, hit_points: f32, impact_angle: f32) {
        self.hit_points += hit_points;

        if impact {
            if self.hit_points <= 0. {
                self.alive = false;
            }

            let shift = 5.;
            self.shift = Vec2::new(shift * impact_angle.sin(), shift * impact_angle.cos());

            if self.alive {
                audio::play_sound(
                    self.impact_sound,
                    PlaySoundParams {
                        volume: TARGET_UNIT_IMPACT_SOUND_VOLUME,
                        ..Default::default()
                    },
                );
            } else {
                self.shift *= 0.4;
                audio::play_sound(
                    self.impact_sound,
                    PlaySoundParams {
                        volume: TARGET_UNIT_IMPACT_SOUND_VOLUME * 0.25,
                        ..Default::default()
                    },
                );
            }
        }
    }

    pub fn draw(&self) {
        let color = if self.alive { WHITE } else { GREEN };

        draw_texture_ex(
            self.texture,
            self.position.x - self.texture.width() * 0.5 + self.shift.x,
            self.position.y - self.texture.height() * 0.5 - self.shift.y,
            color,
            DrawTextureParams {
                ..Default::default()
            },
        );
    }

    pub fn draw_shadow(&self) {
        // тень
        let height = 3.;
        draw_texture_ex(
            self.shadow_texture,
            self.position.x - self.texture.width() * 0.5 + 3. * height,
            self.position.y - self.texture.height() * 0.5 + 4. * height,
            self.color,
            DrawTextureParams {
                ..Default::default()
            },
        );
    }
}

```
